# learning-projects
记录我的C++语言学习
## 一、基础知识

### **1. 晶体管如何实现两种状态来表示01（简单的例子）**

![晶体管逻辑.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f418ed70-8dfb-43a8-810d-4ccca3acbeb4/a0323261-3e71-43e4-b241-c8bbe83702ac/%E6%99%B6%E4%BD%93%E7%AE%A1%E9%80%BB%E8%BE%91.png)

### **2. CPU种类的小小划分**

![cpu划分.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f418ed70-8dfb-43a8-810d-4ccca3acbeb4/6cc3106d-5bcd-407c-bab3-12f6e26ec83d/cpu%E5%88%92%E5%88%86.png)

### **3. CPU位数如何决定内存上限**

![cpu位数如何决定内存上限.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f418ed70-8dfb-43a8-810d-4ccca3acbeb4/b9643016-da18-4b33-82c9-3b88206adc81/cpu%E4%BD%8D%E6%95%B0%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E5%86%85%E5%AD%98%E4%B8%8A%E9%99%90.png)

### **5. 关于流的一些问题**

![标准IO流，文件描述符，管道.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f418ed70-8dfb-43a8-810d-4ccca3acbeb4/c03a425f-8b52-4db6-ab03-ed8d8371113a/%E6%A0%87%E5%87%86IO%E6%B5%81%EF%BC%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%8C%E7%AE%A1%E9%81%93.png)

## 二、指针

**核心要点回顾**

1. **数组指针**：指向数组的指针，类型包括数组的元素类型和数组的大小。
2. **动态内存分配**：使用 `new` 和 `delete` 动态分配和释放内存。
3. **二维数组与指针**：使用指针操作二维数组，支持动态分配和访问。
4. **内存优化与 `const`**：`const` 变量可能被编译器优化为常量折叠，尝试修改 `const` 变量会导致未定义行为。
5. **常量指针和指针常量**：
    - 常量指针：指针指向的值是常量，不能通过指针修改值。
    - 指针常量：指针本身是常量，不能修改指针的指向。

### **1. 数组指针**

- **定义**：数组指针是指向数组的指针，类型包括数组的元素类型和数组的大小。
- **语法**：`int (*p)[5];`（指向包含 5 个 `int` 元素的数组的指针）。
- **特点**：
    - 解引用后得到整个数组。
    - 可以通过指针访问数组元素。
- **代码示例**：
    
    
    ```cpp
    int arr[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &arr;  // p 是指向数组 arr 的指针
    std::cout << (*p)[0];  // 输出 1
    ```
    

---

### **2. 动态内存分配**

- **定义**：使用 `new` 和 `delete` 动态分配和释放内存。
- **语法**：
    - 动态分配单个变量：`int* p = new int;`。
    - 动态分配数组：`int* arr = new int[10];`。
    - 释放内存：`delete p;` 或 `delete[] arr;`。
- **特点**：
    - 动态分配的内存需要手动释放，否则会导致内存泄漏。
    - 适用于需要动态调整大小的数据结构。
- **代码示例**：
    
    ```cpp
    int* p = new int;  // 动态分配一个 int
    *p = 10;
    delete p;  // 释放内存
    
    int* arr = new int[10];  // 动态分配一个包含 10 个 int 的数组
    arr[0] = 1;
    delete[] arr;  // 释放数组内存
    ```
    

---

### **3. 二维数组与指针**

- **定义**：二维数组是一个数组的数组，可以通过指针操作。
- **语法**：
    - 定义二维数组：`int arr[3][4];`。
    - 指向二维数组的指针：`int (*p)[4] = arr;`。
    - 动态分配二维数组：`int (*p)[4] = new int[3][4];`。
- **特点**：
    - 指针的类型需要与二维数组的列数匹配。
    - 动态分配的二维数组需要手动释放内存。
- **代码示例**：
    
    ```cpp
    int arr[3][4] = {
      {1, 2, 3, 4},
      {5, 6, 7, 8},
      {9, 10, 11, 12}
    };
    int (*p)[4] = arr;  // p 是指向二维数组的指针
    std::cout << p[0][0];  // 输出 1
    
    int (*p)[4] = new int[3][4];  // 动态分配一个 3x4 的二维数组
    p[0][0] = 1;
    delete[] p;  // 释放内存
    ```
    

---

### **4. 内存优化与 `const`**

- **定义**：`const` 变量是常量，值不能被修改。
- **特点**：
    - 编译器可能会对 `const` 变量进行**常量折叠**，直接使用初始值。
    - 尝试修改 `const` 变量的值会导致未定义行为。
- **代码示例**：
    
    ```cpp
    const int a{100};
    int* pa2 = (int*)&a;  // 强制类型转换，去除 const 属性
    *pa2 = 101;  // 未定义行为
    std::cout << a;  // 输出 100（常量折叠）
    ```
    

---

### **5. 常量指针和指针常量**

- **常量指针**：
    - 定义：指针指向的值是常量，不能通过指针修改值。
    - 语法：`const int* p = &a;`。
    - 特点：可以修改指针的指向，但不能通过指针修改值。
    - 代码示例：
        
        ```cpp
        int a = 10;
        const int* p = &a;  // 不能通过 p 修改 a 的值
        p = &b;  // 可以修改 p 的指向
        ```
        
- **指针常量**：
    - 定义：指针本身是常量，不能修改指针的指向。
    - 语法：`int* const p = &a;`。
    - 特点：可以修改指针指向的值，但不能修改指针的指向。
    - 代码示例：
        
        ```cpp
        int a = 10;
        int* const p = &a;  // p 不能指向其他地址
        *p = 20;  // 可以修改 p 指向的值
        ```
