# learning-projects
记录我的C++语言学习
## 一、基础知识

### **1. 晶体管如何实现两种状态来表示01（简单的例子）**

<img width="723" alt="晶体管逻辑" src="https://github.com/user-attachments/assets/05be2cf7-a3ee-4d1c-9d3e-9cd635b0b908" />

### **2. CPU种类的小小划分**

<img width="565" alt="cpu划分" src="https://github.com/user-attachments/assets/fa20dd78-be7a-4fd7-9b0e-b8df9da5e1ca" />


### **3. CPU位数如何决定内存上限**

<img width="539" alt="cpu位数如何决定内存上限" src="https://github.com/user-attachments/assets/dafd170c-c6ab-4719-a7ed-deda74ed844e" />


### **5. 关于流的一些问题**

<img width="610" alt="标准IO流，文件描述符，管道" src="https://github.com/user-attachments/assets/2ae17026-6b2a-444f-a8e4-0d8b3f7f14dc" />

## 二、指针

**核心要点回顾**

1. **数组指针**：指向数组的指针，类型包括数组的元素类型和数组的大小。
2. **动态内存分配**：使用 `new` 和 `delete` 动态分配和释放内存。
3. **二维数组与指针**：使用指针操作二维数组，支持动态分配和访问。
4. **内存优化与 `const`**：`const` 变量可能被编译器优化为常量折叠，尝试修改 `const` 变量会导致未定义行为。
5. **常量指针和指针常量**：
    - 常量指针：指针指向的值是常量，不能通过指针修改值。
    - 指针常量：指针本身是常量，不能修改指针的指向。

### **1. 数组指针**

- **定义**：数组指针是指向数组的指针，类型包括数组的元素类型和数组的大小。
- **语法**：`int (*p)[5];`（指向包含 5 个 `int` 元素的数组的指针）。
- **特点**：
    - 解引用后得到整个数组。
    - 可以通过指针访问数组元素。
- **代码示例**：
    
    
    ```cpp
    int arr[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &arr;  // p 是指向数组 arr 的指针
    std::cout << (*p)[0];  // 输出 1
    ```
    

---

### **2. 动态内存分配**

- **定义**：使用 `new` 和 `delete` 动态分配和释放内存。
- **语法**：
    - 动态分配单个变量：`int* p = new int;`。
    - 动态分配数组：`int* arr = new int[10];`。
    - 释放内存：`delete p;` 或 `delete[] arr;`。
- **特点**：
    - 动态分配的内存需要手动释放，否则会导致内存泄漏。
    - 适用于需要动态调整大小的数据结构。
- **代码示例**：
    
    ```cpp
    int* p = new int;  // 动态分配一个 int
    *p = 10;
    delete p;  // 释放内存
    
    int* arr = new int[10];  // 动态分配一个包含 10 个 int 的数组
    arr[0] = 1;
    delete[] arr;  // 释放数组内存
    ```
    

---

### **3. 二维数组与指针**

- **定义**：二维数组是一个数组的数组，可以通过指针操作。
- **语法**：
    - 定义二维数组：`int arr[3][4];`。
    - 指向二维数组的指针：`int (*p)[4] = arr;`。
    - 动态分配二维数组：`int (*p)[4] = new int[3][4];`。
- **特点**：
    - 指针的类型需要与二维数组的列数匹配。
    - 动态分配的二维数组需要手动释放内存。
- **代码示例**：
    
    ```cpp
    int arr[3][4] = {
      {1, 2, 3, 4},
      {5, 6, 7, 8},
      {9, 10, 11, 12}
    };
    int (*p)[4] = arr;  // p 是指向二维数组的指针
    std::cout << p[0][0];  // 输出 1
    
    int (*p)[4] = new int[3][4];  // 动态分配一个 3x4 的二维数组
    p[0][0] = 1;
    delete[] p;  // 释放内存
    ```
    

---

### **4. 内存优化与 `const`**

- **定义**：`const` 变量是常量，值不能被修改。
- **特点**：
    - 编译器可能会对 `const` 变量进行**常量折叠**，直接使用初始值。
    - 尝试修改 `const` 变量的值会导致未定义行为。
- **代码示例**：
    
    ```cpp
    const int a{100};
    int* pa2 = (int*)&a;  // 强制类型转换，去除 const 属性
    *pa2 = 101;  // 未定义行为
    std::cout << a;  // 输出 100（常量折叠）
    ```
    

---

### **5. 常量指针和指针常量**

- **常量指针**：
    - 定义：指针指向的值是常量，不能通过指针修改值。
    - 语法：`const int* p = &a;`。
    - 特点：可以修改指针的指向，但不能通过指针修改值。
    - 代码示例：
        
        ```cpp
        int a = 10;
        const int* p = &a;  // 不能通过 p 修改 a 的值
        p = &b;  // 可以修改 p 的指向
        ```
        
- **指针常量**：
    - 定义：指针本身是常量，不能修改指针的指向。
    - 语法：`int* const p = &a;`。
    - 特点：可以修改指针指向的值，但不能修改指针的指向。
    - 代码示例：
        
        ```cpp
        int a = 10;
        int* const p = &a;  // p 不能指向其他地址
        *p = 20;  // 可以修改 p 指向的值
        ```
